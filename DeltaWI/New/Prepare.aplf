 result←object Prepare arg;sub;illegal;final;v0;vars;acts;action;aarg
 ⍝ Finish initializing a just-created new GUI object
 ⍝ The action and class have already been removed from the argument list.

 ⍝ Watch out for things that can't be handled on a New-command
 illegal←'Create' 'New' ⍝? What else might be illegal here (by name)?
 '∆WI OBJECT ERROR: Object already exists'##.Error∨/illegal∊⊃¨⊆¨arg

 object._self↓⍨←2×'#.'≡2↑object._self ⍝ Make sure that _self doesn't have a leading '#.' on it (may be created by top-level New functions)

 object ##.∆WSet('Coord' 'RealPixel')('AutoConf' 0)('Visible' 0) ⍝ Everybody needs these (that have them)
 :Select object._class
 :Case 'Menu'
     ⍝ An APL+Win Menu object may be any of four Dyalog object-types depending on context.
     ⍝ That much should have been handled by Menu.New by now.
     ⍝? Hmmm... will Menu.New create the MenuBar part of a top-level menu (probably not) or the named Menu item upon it? Start hidden and relocate??
     ⍝? Can we look backwards (up the stack) to handle this properly?
     ⍝? Is there anything else we need to do specially here?
 :Case 'MDIForm'
     sub←⎕VGET((⍕object),'._mdi')##.∆WC'MDIClient'('Coord' 'RealPixel')('AutoConf' 0)
     sub._Owner←object
 :Case 'Picture'
     object ##.∆WS'Coord' 'User' ⍝ A picture object's parent needs an exception to Coord
     sub←⎕VGET((⍕object),'._pic')##.∆WC'SubForm'('Coord' 'RealPixel')('AutoConf' 0)
     sub._Owner←object
     ⍝? Now we're going to need to attach a file-less Bitmap object so this can be drawn on.
 :EndSelect

 ⍝ Assign class default pseudo-properties and variables
 object.(_scale _opened _visible _enabled)←1 0 1 1 ⍝ All new objects default to scale=1, not-yet-logically-open, but otherwise visible
 vars←object._Class.⎕NL ¯2.1 ⍝ What variables are in this namespace (including currently-executing locals)
 vars←(~1∊¨⊃¨object._Class.⎕STATE¨vars)/vars ⍝ Remove currently-executing locals to leave only globals
 object ⎕VSET(↑vars)(object._Class ⎕VGET vars) ⍝ Replicate them in the new object

 ⍝ Apply list of application-specific properties and methods to this new object
 final←'Close' 'Hide' 'Show' 'Open' ⍝ Methods that are not done until the very end (the last of these being the default)
 acts←⊃¨arg←⊆¨arg
 :For action :In (~acts∊final)/arg
     ⍝ We'll handle these by calling ∆WI recursively and hope we won't get interrupted or slow down
     {}object._self ##.∆WI action ⍝ Call ∆WI to do the work, but we can never use a returned result from these operations
 :EndFor

 ⍝ Activate/show the new object as requested
 object._opened←1 ⍝ It will end up opened, unless 'Close' turns it off
 :For action :In final∩⍨acts,(~∨/final∊acts)/¯1↑final ⍝ There should usually only be one of these at most; default=Open
⍝? Watch out for possible inheriting from parentage?
     aarg←1↓(acts⍳⊂action)⊃arg,⊂⍬
     v0←-object._class⊂⍛∊'Form' 'MDIForm' 'Menu' ⍝ "Invisible" setting for this class
     :Select action
     :Case 'Close'
         object._opened←0
         object ##.∆WSet('Active' 0)('Visible' 0)
     :Case 'Hide'
         object._visible←v0
         'Hide'##.Event object ##.Application,aarg ⍝ Run the onHide event handler with arguments
         object ##.∆WSet('Active' 1)('Visible' 0)
     :Case 'Show'
         object('Show'##.Invoke)aarg ⍝ Use its normal Show method which includes firing events
         ⍝object ##.∆WSet('Active' 0)('Visible' 1)
         ⍝object ⎕VSET('_opened' 1)('_visible' 1)('_enabled' 1)
     :Case 'Open' ⍝ Or none of the above
         object._opened←0 ⍝ Pretend that it's not open yet so we can call the standard routine
         object('Open'##.Invoke)aarg ⍝ Use its normal Open method which includes firing events
         object ##.∆WSet⊂'Visible' 1
         ⍝object ⎕VSET('_opened' 1)('_visible' 1)('_enabled' 1)
     :EndSelect
 :EndFor

 result←object._self ⍝ Finally, give them back the GUI name of the object that they created
