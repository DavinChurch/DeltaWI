 {WRES}←{parms}Run expression;back;requote;wres;ns
⍝ Execute the given expression in the Application's calling name scope (no explicit result from expression, just ∆WRES)
⍝ Allow setting of both (not just one) ∆WARG and ∆WRES in the optional argument.
⍝ Return the application's ∆WRES value.

 :If 2=⎕NC'parms'                               ⍝ Let's allow them to set both event variables via the left argument
 :AndIf 2=≢parms                                ⍝ (Both must be included to make the correct nesting assumptions)
     ⍝ If the first item of ∆WARG is itself a namespace reference, then let's assume that they have not removed
     ⍝ the two message-prefix items before passing it to me, and do it automatically here.
     :If 0=≡ns←⊃⊃parms ⋄ :AndIf 9=⎕NC'ns' ⋄ (1⊃parms)↓⍨←2 ⋄ :EndIf ⍝ So they don't have to bother dropping this off every time
     Application.∆WARG←Single 1⊃parms           ⍝ Auto-disclose singleton
     Application.∆WRES←wres←2⊃parms
 :ElseIf 9=⎕NC'parms'                           ⍝ Or if it's a namespace we can set values selectively
     Application.(∆WARG ∆WRES)←parms ⎕VGET(↑'∆WARG' '∆WRES')Application.(∆WARG ∆WRES)
     ⍝ If the first item of ∆WARG is itself a namespace reference, then let's assume that they have not removed
     ⍝ the two message-prefix items before passing it to me, and do it automatically here.
     :If 0=≡ns←⊃Application.∆WARG ⋄ :AndIf 9=⎕NC'ns' ⋄ Application.∆WARG↓⍨←2 ⋄ :EndIf ⍝ So they don't have to bother dropping this off every time
     wres←Application.∆WRES
 :Else
     wres←Application ⎕VGET⊂'∆WRES' 0           ⍝ At least make an assumption about the default return value if it gets erased
     ⍝ The event callback better not have erased the values of ∆WARG & ∆WRES
 :EndIf

 :If ×≢expression
     requote←'''[^'']*''' '"[^"]*"'⎕R{⍵.('\"' ''''⎕R'''' ''''''⍣PatternNum⊢Match)} ⍝ Convert any double-quotes into single-quotes before execution
     back←Application⍕⍛,'.'                     ⍝ Which namespace are we looking for?
     back←1-⍨back⍳⍨⍥⊆⎕XSI↑¨⍨≢back               ⍝ How far back is it in the )SI?
     back(86⌶)requote expression                ⍝ Execute the expression at the correct (most recent) point of the application
 :EndIf
⍝? Instead of just going back until we hit the application scope, should we instead be going all the way back to the ∆WI call itself?
⍝? Does it make a difference? (Only for interim-shadowed variables??)
⍝? Maybe just going back to the most local application scope makes sense for events, since they may be called anytime?

 WRES←Application ⎕VGET⊂'∆WRES'wres             ⍝ Return result to the calling function for easier access (but shy so it won't just print)
