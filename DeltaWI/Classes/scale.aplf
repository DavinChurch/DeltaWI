 result←object scale arg;size;units;scale;border;Borders;psize;pscale;tunits;punits;margins;ppxsize;extent
⍝ Request or modify the scaling factor of a GUI object

 :If (1=≢arg)∧1<|≡arg ⋄ arg←⊃arg ⋄ :EndIf ⍝ Make sure a nested argument is disclosed

 :Section ⍝ Get all our basic information
     (extent size scale border)←object ⎕VGET('_extent'⍬)('_size'⍬)('_scale'⍬)('_border' 0) ⍝ My current settings
     (psize pscale ppxsize)←(⊃object._Ancestry)⎕VGET('_size'⍬)('_scale' 1)('_pix_size'(0 0)) ⍝ Parent's 'size' & 'scale' (for use by 'where' and 'extent')
     units←##.GUIroot._units ⍝ Get system conversion factors
     punits←(units⍪⍨ppxsize÷|2↑3↓pscale)[1+⊃pscale;] ⍝ Compute unit-conversions for the parent object's scale
     Borders←_supp.GetBorders object ⍝ Time to figure out what the border definitions are for this class (capitalized because it represents a global)
 :EndSection

 :Section  ⍝ Are they just asking for the current setting?
     :If 0=≢arg
         result←scale
         :If ×⊃scale ⍝ If it's a fixed scale, make sure we return the proper final four items
             result←(1↑scale),0 0,size
         :Else
             ⍝ If it's proportional, it better have all 5 items already, set by the application
         :EndIf
         :Return ⍝ And that's all we're doing, so it's time to exit
     :EndIf
 :EndSection

 :Section ⍝ Convert structure to a single value for a non-zero 'scale' or exactly 5 items when using a zero 'scale'
     :If (0≠⊃arg)∧arg≢⍛∊1 5
         arg←1↑arg ⍝ A fixed scaling factor ignores further arguments
     :Else
         :Select ≢arg ⍝ A proportional scaling factor allows a variety of input structures
         :Case 1
             arg←arg,0 0 0 0 ⍝ This is consistent but will produce an error below
         :Case 2
             arg←0 0 0,arg
         :Case 4
             arg←0,arg
         :Case 5
             ⍝ They've given us all 5 items
         :Else
             ##.Error'∆WI LENGTH ERROR: scale'
         :EndSelect
         '∆WI DOMAIN ERROR: scale'##.Error 0∊arg[4 5]
     :EndIf
 :EndSection

 :Section ⍝ Figure out conversion needs for 'size'
     :Select ×⊃¨scale arg ⍝ Are we converting to or from proportional scaling?
     :Case 0 0 ⍝ Staying in proportional, but maybe changing factors
         size←arg[4 5] ⍝ Just directly setting new 'size' values
     :Case 0 1 ⍝ Converting from proportional to fixed
         tunits←(1⍪units)[1+⊃arg;] ⍝ Compute new-scale unit-conversions for this object's 'scale'
         margins←+/2 2⍴+⌿Borders[1;,2;] ⍝ Differences between 'extent' and 'size' (in pixels)
         size←tunits×margins-⍨extent×punits ⍝ Convert to new units
         object.⎕ex '_pix_size' ⍝ This isn't valid any more
     :Case 1 0 ⍝ Converting from fixed to proportional
         ⍝ This needs to create an actual pixel-size notation for later use
         object._pix_size←size×(1⍪units)[1+⊃scale;] ⍝ How big is this object in pixels? Remember it for later sizing needs.
         size←arg[4 5] ⍝ Just directly setting new 'size' values
     :Case 1 1 ⍝ Remaining fixed, but maybe changing units
         size←(1⍪units)[1+⊃arg;]÷⍨size×(1⍪units)[1+⊃scale;] ⍝ Convert to new units
     :EndSelect
 :EndSection

 :Section ⍝ Set APL+Win properties (Dyalog properties don't change)
     scale←arg ⍝ Now we can set the new property value from what they gave us
     :If scale⊃⍛∊5 6 ⋄ (size scale)←⌊0.5+size scale ⋄ :EndIf ⍝ If new 'scale' is in pixels, round to integers
     object.(_size _scale)←size scale ⍝ Set new APL+Win reference values
⍝? Make adjustments for closed object handling
 :EndSection

 result←NoRes
